import WebSocket from "ws";
import { readFile } from "fs/promises";

import {
  sleep,
  updateTrackable,
  getTrackable,
  getAllFences,
  getAllTrackablesInsideFence,
  constructLocation,
} from "./tools.js";
import { getRouteByBarcode } from "./data/productList.js";

// The base URL at which the DeepHub can be contacted.
const baseUrl = "http://localhost:8081/deephub/v1";

// List of provider ids used for the forklifts to transport products to the truck.
const forkliftProviderIds = ["ac:de:23:67:10:47", "ac:de:23:67:10:48"];

// Determine the id of the zone to be used for the transformation of local coordinates.
const zoneId = JSON.parse(await readFile("./data/zone.json")).id;

// The list of jobs for picking up products by the forklifts.
const pendingJobs = [];

// The list of active jobs for picking up products.
const activeJobs = [];

// The list of production areas.
const productionAreaIds = [];

// A websocket connection to the DeepHub. This connection is used to listen for fence events, which in turn trigger various actions in this script.
const ws = new WebSocket("ws://localhost:8081/deephub/v1/ws/socket");
ws.on("open", async function open() {
  console.log("open");

  // Subscribe to fence events with this websocket connection.
  ws.send(
    JSON.stringify({
      event: "subscribe",
      topic: "fence_events",
    })
  );

  try {
    // Initialize the currently existing products and pending jobs.
    await init();

    await updateForkliftLoop();
  } catch (err) {
    console.log(err);
  }
});

// Process a received websocket message.
ws.on("message", async function message(buffer) {
  const data = JSON.parse(buffer);
  if (data.event !== "message") return;

  for (const payload of data.payload) {
    // If the event was not generated by a trackable, there is nothing to do.
    if (!payload.trackable_id) continue;

    // If the message is a fence entry for a production area, then we add the products transport jobs to the respective list.
    if (
      payload.event_type === "region_entry" &&
      productionAreaIds.includes(payload.fence_id)
    ) {
      updatePendingJobs(await getTrackable(baseUrl, payload.trackable_id));
      console.log("Received fence entry event for production area:\n", payload);
      console.log(
        "Forklifts:",
        forkliftProviderIds.length,
        "Pending Jobs:",
        pendingJobs.length
      );
    }
  }
});

function updatePendingJobs(trackable) {
  const route = getRouteByBarcode(trackable.properties.barcode);
  pendingJobs.push({
    trackable,
    route,
    step: 0,
    isFirstWay: true,
  });
}

async function init() {
  // Retrieve all fences which are marked as a production area.
  const productionAreaFences = (await getAllFences(baseUrl)).filter(
    (fence) => !!fence.properties && fence.properties.isProductionArea
  );

  // Add the ids of all production areas to the respective list. Also retrieve all trackables which are inside these areas.
  const trackableInsideProductionAreas = [];
  for (const fence of productionAreaFences) {
    productionAreaIds.push(fence.id);
    trackableInsideProductionAreas.push(
      getAllTrackablesInsideFence(baseUrl, fence.id)
    );
  }

  // Add pending jobs for all available products.
  let existingProducts = (
    await Promise.all(trackableInsideProductionAreas)
  ).flat();
  for (const product of existingProducts) {
    updatePendingJobs(product);
  }
}

async function startForklift() {
  const forkliftProviderId = forkliftProviderIds.shift();
  const job = pendingJobs.shift();

  // Attach the products trackable to the forklifts location provider.
  const trackable = await getTrackable(baseUrl, job.trackable.id);
  await updateTrackable(baseUrl, {
    ...trackable,
    location_providers: [forkliftProviderId],
  });

  // Add the forklifts job to the list of active jobs.
  activeJobs.push({
    ...job,
    trackable,
    forkliftProviderId,
  });
}

async function moveForklift(data) {
  if (data.isFirstWay) {
    // The forklift is on its way to the storage area.
    if (data.step < data.route.length) {
      // The forklift has not yet reached the products storage location.
      ws.send(
        constructLocation(data.route[data.step], data.forkliftProviderId, {
          zoneId: zoneId,
          crs: "local",
        })
      );
      data.step++;
    } else {
      // The forklift has reached the products storage location.
      // We detach the products trackable from the forklifts location provider.
      const trackable = await getTrackable(baseUrl, data.trackable.id);
      await updateTrackable(baseUrl, {
        ...trackable,
        location_providers: [],
        properties: { ...trackable.properties, storage_place: true },
      });

      // Reset the forklifts job parameters for the return trip to the production area.
      delete data.trackable;
      data.step = data.route.length - 1;
      data.isFirstWay = false;
    }
  } else {
    // The forklift is on its way back to the production area.
    if (data.step >= 0) {
      // The forklift has not yet reached the production area.
      ws.send(
        constructLocation(data.route[data.step], data.forkliftProviderId, {
          zoneId: zoneId,
          crs: "local",
        })
      );
      data.step--;
    } else {
      // The forklift has reached the production area. Remove the job from the active list and make the forklift available again.
      activeJobs.splice(activeJobs.indexOf(data), 1);
      forkliftProviderIds.push(data.forkliftProviderId);
    }
  }
}

async function updateForkliftLoop() {
  const start = Date.now();

  // If a forklift is available and there are pending jobs, start a new forklift job.
  if (forkliftProviderIds.length && pendingJobs.length) {
    await startForklift();
  }

  // Move all forklifts one step forward on their route.
  const updateList = [];
  for (const job of activeJobs) {
    updateList.push(moveForklift(job));
  }
  await Promise.all(updateList);

  await sleep(100 - (Date.now() - start));
  await updateForkliftLoop();
}
