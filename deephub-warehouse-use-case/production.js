import WebSocket from "ws";
import fetch from "node-fetch";
import { readFile } from "fs/promises";

import { productDataList } from "./data/productList.js";
import {
  sleep,
  shuffle,
  createTrackable,
  updateTrackable,
  getTrackable,
  getAllTrackables,
  isLoadingRamp,
} from "./tools.js";

// The base URL at which the DeepHub can be contacted.
const baseUrl = "http://localhost:8081/deephub/v1";

// Determine the zone id from the temporary file, which is required for location updates in local coordinates.
const zoneId = JSON.parse(await readFile("./data/zone.json")).id;

// A list of products in the process of being loaded onto the truck.
const transitingProducts = [];

// The list of all currently existing products.
let existingProducts = [];

// A websocket connection to the DeepHub. This connection is used to listen for fence events, which in turn trigger various actions in this script.
const ws = new WebSocket("ws://localhost:8081/deephub/v1/ws/socket");
ws.on("open", async function open() {
  console.log("open");

  // Subscribe to fence events with this websocket connection.
  ws.send(
    JSON.stringify({
      event: "subscribe",
      topic: "fence_events",
    })
  );

  try {
    // Initialize all products from the product data list.
    await init(productDataList);

    // Reproduce missing products based on the product list. This runs endlessly.
    await produceLoop(productDataList);
  } catch (err) {
    console.log(err);
  }
});

// Process a received websocket message.
ws.on("message", function message(buffer) {
  const data = JSON.parse(buffer);
  if (data.event !== "message") return;

  for (const payload of data.payload) {
    // If the event was not generated by a trackable, there is nothing to do.
    if (!payload.trackable_id) continue;

    // If the event is a fence entry to the loading ramp, add the products trackable id to the watch list.
    if (
      payload.event_type === "region_entry" &&
      isLoadingRamp(payload.fence_id)
    ) {
      console.log("Received fence entry event for loading ramp:\n", payload);
      transitingProducts.push(payload.trackable_id);
    }
  }
});

async function checkForDeletedProducts() {
  const len = transitingProducts.length;
  let i = 0;
  for (; i < len; i++) {
    const requestResult = await getTrackable(baseUrl, transitingProducts[i]);

    if (requestResult.type === "not found") {
      // The product has been deleted / loaded onto the truck.
      // Remove it from the list of transiting products and update the list of existing products.
      transitingProducts.splice(i, 1);
      existingProducts = (await getAllTrackables(baseUrl)).filter(
        (product) => !!product.properties.product
      );
    } else if (!requestResult.properties.product) {
      // The request returned something other than a product. Remove it from the list.
      transitingProducts.splice(i, 1);
    }
  }
}

async function addOneProduct(requestedProducts) {
  for (const requestedProduct of shuffle(requestedProducts)) {
    const requestedAmount = requestedProduct.count;
    const requestedBarcode = requestedProduct.properties.barcode;

    // Determine how many products of the requested type are already available.
    const availableProducts = existingProducts.filter(
      (product) => product.properties.barcode === requestedBarcode
    );

    if (availableProducts.length < requestedAmount) {
      console.log(
        requestedBarcode,
        "- available:",
        availableProducts.length,
        "requested:",
        requestedAmount
      );

      // Add one trackable corresponding to the requested product type.
      const product = await createTrackable(baseUrl, {
        radius: 0.5,
        type: "virtual",
        location_providers: [requestedProduct.providerId],
        properties: requestedProduct.properties,
      });
      // Remove the initial location provider from the just created trackable.
      await updateTrackable(baseUrl, {
        ...product,
        ...{ location_providers: [] },
      });

      // Add the just created product to the list of existing products.
      existingProducts.push(product);
      return;
    }
  }
}

async function init(products) {
  // Initialize the location providers corresponding to the starting locations of the products.
  // We do this by sending an initial location update for each location provider based on the list of products.
  for (const product of products) {
    await fetch(`${baseUrl}/providers/locations`, {
      method: "put",
      body: JSON.stringify([
        {
          position: {
            type: "Point",
            coordinates: product.route[0], // The starting position (in "Finished Products")
          },
          source: zoneId,
          provider_type: "uwb",
          crs: "local",
          provider_id: product.providerId, // The provider id corresponding to the finished products location.
        },
      ]),
      headers: { "Content-Type": "application/json" },
    });
  }

  // Determine the currently existing products from the list of all trackables.
  existingProducts = (await getAllTrackables(baseUrl)).filter(
    // We recognize a product by it having a property "product".
    (product) => !!product.properties.product
  );
}

async function produceLoop(requestedProducts) {
  const start = Date.now();

  // Add one product based on the list of requested products.
  await addOneProduct(requestedProducts);

  // If there are products in transit, we need to check whether they have been loaded to the truck by now (removed).
  if (transitingProducts.length) {
    await checkForDeletedProducts();
  }

  await sleep(100 - (Date.now() - start));

  await produceLoop(requestedProducts);
}
